#!groovy

/**
 * WishList multi branch frontend pipeline
 */

def err = null
currentBuild.result = "SUCCESS"

properties([
  buildDiscarder(logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '', numToKeepStr: '25')),
  pipelineTriggers([pollSCM('H/5 * * * *')])
])

try {
  String imageName = 'frontend'
  String commitHash

  node() {

    echo "JENKINS_HOME = ${env.JENKINS_HOME}"
    echo "WORKSPACE = ${env.WORKSPACE}"
    echo "JOB_NAME = ${env.JOB_NAME}"
    echo "BUILD_NUMBER = ${env.BUILD_NUMBER}"

    stage('checkout') {
      checkout scm
      commitHash = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
      echo "BRANCH_NAME = ${env.BRANCH_NAME}"
    }

    stage('install packages') {
      // complete step
    }

    stage('unit test with coverage') {
      try {
        // complete step
      } finally {
        junit allowEmptyResults: false, testResults: 'reports/unit/*.xml'
        publishHTML([allowMissing: false, alwaysLinkToLastBuild: true, keepAll: true, reportDir: 'reports/unit', reportFiles: 'testresults.html', reportName: 'Unit Test Report'])
        publishHTML([allowMissing: false, alwaysLinkToLastBuild: true, keepAll: true, reportDir: 'reports/coverage', reportFiles: 'index.html', reportName: 'Code Coverage Report'])
      }
    }

    stage('linting') {
      // complete step
    }

    stage('run protractor tests') {
      try {
        // complete step
      } finally {
        step([$class: 'CucumberReportPublisher', jsonReportDirectory: "reports/e2e/json"])
      }
    }

    if (env.BRANCH_NAME != 'master') {
      stage('check build docker') {
        // complete step
        // Here we will not use the earlier created npm script but we will use a Jenkins docker command.
        // Add the following: docker.build("<image-name>"). Hint: the image name is defined as a variable on top
        // of this Jenkinsfile.
      }
    }
  }

  if (env.BRANCH_NAME == 'master') {
    node() {
      stage('build package') {
        // complete step
      }

      stage('build docker') {
        // complete step
        // For this step we cannot use the npm script we created in part 2. For the continuous deployment we need to now
        // which code is running. If we always use the docker tag latest, we will never get to know this. To solve this
        // issue we use the git commit tag as docker tag. Now we know exactly which code is running in production.
        // Add the following: docker.build("<image-name>:<commit-hash>").
      }
    }

    /**
     * Make sure to put milestones outside the Jenkins "node" block to free up Jenkins executor slots. Otherwise, these
     * slots keep being occupied eventually blocking new Jenkins jobs.
     */
    stage('promote-prod') {
      milestone()
      input "Promote ${commitHash} to prod?"
      milestone()
    }

    node() {
      stage('rollout frontend prod') {
        // complete step
        // This step has already been completed for you. But it's important to understand what happens here. Since we
        // have build an image with a git commit tag, we need to deploy the image with this tag to Kubernetes. If you
        // take a look at the kubernetes deployment descriptor you can see that it is always deploying the image
        // frontend:latest. To solve this issue we use the stream editor sed. So, the below command changes the line
        // [image: frontend:latest] into [image: frontend:commitHash] and pipes the result to kubctl. Now we know
        // for sure that we are deploying the correct image to Kubernetes.
        sh "sed -r 's/(\\s+image:{1}.+:)(.+)/\\1${commitHash}/' kubernetes/frontend.yml | kubectl apply -n prod -f -"
      }
    }
  }
} catch (caughtError) {
  err = caughtError
  currentBuild.result = "FAILURE"
} finally {
  // You may want to add build result notifications here (e.g. mail, slack notify, etc.)
  if (err) {
    throw err
  }
}
